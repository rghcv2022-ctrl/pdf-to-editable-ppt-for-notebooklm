import os
import io
import copy
import numpy as np
from PIL import Image
import cv2

from pdf2image import convert_from_path
from paddleocr import PaddleOCR
from pptx import Presentation
from pptx.util import Pt, Inches
from pptx.dml.color import RGBColor
from pptx.enum.text import MSO_ANCHOR, MSO_AUTO_SIZE
from pptx.enum.shapes import MSO_SHAPE_TYPE

# ================= 配置区域 =================
POPPLER_PATH = None
WATERMARK_KEYWORDS = ["notebooklm", "generated by", "google"]
FONT_SCALE = 0.45  # 维持大字号策略
# ===========================================

def px_to_inches(px, dpi=72):
    return px / dpi

def get_larger_font_size(h_px):
    pt = h_px * FONT_SCALE
    if pt > 40: return 44
    elif pt > 30: return 36
    elif pt > 24: return 28
    elif pt > 18: return 24
    elif pt > 14: return 18
    else: return 14

def get_text_color_kmeans(pil_image, box):
    """K-Means 聚类取色"""
    try:
        img_np = np.array(pil_image)
        x1, y1 = max(0, int(box[0][0])), max(0, int(box[0][1]))
        x2, y2 = min(img_np.shape[1], int(box[2][0])), min(img_np.shape[0], int(box[2][1]))
        
        if x2 <= x1 or y2 <= y1: return RGBColor(0, 0, 0)
        
        roi = img_np[y1:y2, x1:x2]
        if roi.size == 0: return RGBColor(0, 0, 0)
        
        if roi.shape[2] == 4: roi = cv2.cvtColor(roi, cv2.COLOR_RGBA2RGB)
        elif roi.shape[2] == 1: roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2RGB)
        
        data = roi.reshape((-1, 3))
        data = np.float32(data)
        
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
        K = 2
        _, labels, centers = cv2.kmeans(data, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
        
        count_0 = np.sum(labels == 0)
        count_1 = np.sum(labels == 1)
        
        text_color_idx = 0 if count_0 < count_1 else 1
        color = centers[text_color_idx]
        r, g, b = int(color[0]), int(color[1]), int(color[2])
        if r > 240 and g > 240 and b > 240: return RGBColor(20, 20, 20)
        return RGBColor(r, g, b)
    except:
        return RGBColor(0, 0, 0)

def smart_background_clean_aggressive(pil_image, ocr_result):
    """强力背景清洗"""
    img_np = np.array(pil_image)
    if img_np.shape[2] == 4: img_np = cv2.cvtColor(img_np, cv2.COLOR_RGBA2RGB)
    img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
    
    mask = np.zeros(img_cv.shape[:2], dtype=np.uint8)
    if ocr_result:
        for line in ocr_result:
            box = line[0]
            points = np.array(box, dtype=np.int32)
            cv2.fillPoly(mask, [points], 255)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (20, 8))
    dilated_mask = cv2.dilate(mask, kernel, iterations=2)
    feathered_mask = cv2.GaussianBlur(dilated_mask, (15, 15), 0)
    clean_img_cv = cv2.inpaint(img_cv, feathered_mask, 5, cv2.INPAINT_TELEA)
    return Image.fromarray(cv2.cvtColor(clean_img_cv, cv2.COLOR_BGR2RGB))

def merge_text_blocks(ocr_data):
    """段落合并"""
    if not ocr_data: return []
    sorted_data = sorted(ocr_data, key=lambda x: x[0][0][1])
    merged_blocks = []
    
    current_block = {
        'lines': [sorted_data[0][1][0]],
        'box': sorted_data[0][0],
        'avg_height': (sorted_data[0][0][2][1] - sorted_data[0][0][0][1]),
        'sample_box': sorted_data[0][0]
    }

    for i in range(1, len(sorted_data)):
        line = sorted_data[i]
        box = line[0]
        text = line[1][0]
        h = box[2][1] - box[0][1]
        
        prev_box = current_block['box']
        v_dist = box[0][1] - prev_box[2][1]
        h_diff = abs(box[0][0] - prev_box[0][0])
        height_diff = abs(h - current_block['avg_height'])
        
        if v_dist < 30 and h_diff < 50 and height_diff < 15:
            current_block['lines'].append(text)
            new_x1 = min(prev_box[0][0], box[0][0])
            new_y1 = prev_box[0][1]
            new_x2 = max(prev_box[2][0], box[2][0])
            new_y2 = box[2][1]
            current_block['box'] = [[new_x1, new_y1], [new_x2, new_y1], [new_x2, new_y2], [new_x1, new_y2]]
            current_block['avg_height'] = (current_block['avg_height'] + h) / 2
        else:
            merged_blocks.append(current_block)
            current_block = {
                'lines': [text],
                'box': box,
                'avg_height': h,
                'sample_box': box
            }
    merged_blocks.append(current_block)
    return merged_blocks

# ================= 核心处理逻辑封装 =================

def process_single_image_content(pil_img, ocr_engine):
    """
    输入一张 PIL 图片，返回：(清洗后的背景PIL, 合并后的文字块列表)
    """
    img_np = np.array(pil_img)
    result = ocr_engine.ocr(img_np, cls=True)
    raw_data = result[0] if result else []
    
    # 过滤水印
    clean_ocr_data = []
    for line in raw_data:
        text = line[1][0]
        if not any(kw in text.lower() for kw in WATERMARK_KEYWORDS):
            clean_ocr_data.append(line)
            
    # 背景清洗
    clean_bg = smart_background_clean_aggressive(pil_img, raw_data)
    # 段落合并
    merged_blocks = merge_text_blocks(clean_ocr_data)
    
    return clean_bg, merged_blocks

def create_text_boxes_on_slide(slide, merged_blocks, original_img, offset_x=0, offset_y=0, scale_x=1.0, scale_y=1.0):
    """在 Slide 上根据 OCR 结果生成文本框"""
    for block in merged_blocks:
        box = block['box']
        lines = block['lines']
        avg_h = block['avg_height']
        
        # 取色
        text_color = get_text_color_kmeans(original_img, block['sample_box'])
        full_text = "\n".join(lines)
        
        # 坐标转换 (像素 -> 英寸 -> 幻灯片坐标)
        # 注意：这里需要加上图片的偏移量 (如果是 PPT 内的图片)
        x1_px, y1_px = box[0]
        w_px = box[2][0] - x1_px
        h_px = box[2][1] - y1_px
        
        # 计算在 PPT 中的实际位置
        final_left = offset_x + Inches(px_to_inches(x1_px * scale_x, 150))
        final_top = offset_y + Inches(px_to_inches(y1_px * scale_y, 150))
        final_width = Inches(px_to_inches(w_px * scale_x, 150))
        final_height = Inches(px_to_inches(h_px * scale_y, 150))
        
        txBox = slide.shapes.add_textbox(final_left, final_top, final_width, final_height)
        txBox.fill.background() # 透明
        
        tf = txBox.text_frame
        tf.word_wrap = False
        tf.auto_size = MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT
        tf.margin_left = 0
        tf.margin_right = 0
        tf.margin_top = 0
        tf.margin_bottom = 0
        
        p = tf.paragraphs[0]
        p.text = full_text
        p.font.name = 'Microsoft YaHei'
        p.font.color.rgb = text_color
        # 修正字号逻辑：因为 PPT 内图片可能被缩放，这里简化处理，还是用像素高度估算
        p.font.size = Pt(get_larger_font_size(avg_h * scale_y)) 
        p.line_spacing = 1.1

# ================= 文件类型处理 =================

def process_pdf_file(pdf_path, output_ppt_path, ocr_engine):
    """处理 PDF：全页转图 -> 重构 (适用于去水印/扫描件)"""
    print(f"--- 模式: PDF 全页重构 ---")
    try:
        images = convert_from_path(pdf_path, dpi=150, poppler_path=POPPLER_PATH)
    except Exception as e:
        print(f"PDF 读取失败: {e}")
        return

    prs = Presentation()
    for i, img in enumerate(images):
        print(f"处理第 {i+1} 页...")
        
        # 核心处理
        clean_bg, blocks = process_single_image_content(img, ocr_engine)
        
        # PPT 页面设置
        img_w, img_h = img.size
        slide = prs.slides.add_slide(prs.slide_layouts[6])
        ppt_w = int(px_to_inches(img_w, 150) * 914400)
        ppt_h = int(px_to_inches(img_h, 150) * 914400)
        prs.slide_width = ppt_w
        prs.slide_height = ppt_h
        
        # 贴背景
        image_stream = io.BytesIO()
        clean_bg.save(image_stream, format='JPEG', quality=95)
        image_stream.seek(0)
        slide.shapes.add_picture(image_stream, 0, 0, width=ppt_w, height=ppt_h)
        
        # 贴文字 (无偏移，比例1.0)
        create_text_boxes_on_slide(slide, blocks, img)
        
    prs.save(output_ppt_path)
    print(f"PDF 转换完成: {output_ppt_path}")

def process_pptx_file(input_pptx, output_pptx, ocr_engine):
    """处理 PPTX：保留文本框，仅重构图片中的内容"""
    print(f"--- 模式: PPTX 混合编辑 (保留原文本，修复图片) ---")
    
    prs = Presentation(input_pptx)
    
    for slide_idx, slide in enumerate(prs.slides):
        print(f"分析幻灯片 {slide_idx + 1}...")
        
        # 收集需要处理的图片形状 (不能一边遍历一边修改)
        shapes_to_process = []
        
        for shape in slide.shapes:
            # 1. 如果是文本框 -> 跳过 (保留原始可编辑性)
            if shape.has_text_frame:
                continue
                
            # 2. 如果是图片 -> 记录下来准备处理
            if shape.shape_type == MSO_SHAPE_TYPE.PICTURE:
                shapes_to_process.append(shape)
        
        # 开始处理识别到的图片
        for shape in shapes_to_process:
            try:
                # 提取图片数据
                image_blob = shape.image.blob
                img_pil = Image.open(io.BytesIO(image_blob))
                
                # 核心处理：OCR + 清洗
                clean_bg, blocks = process_single_image_content(img_pil, ocr_engine)
                
                # 如果没识别出字，就不动这个图了，省的变模糊
                if not blocks:
                    continue
                
                print(f"  -> 发现图片包含文字，正在重构...")
                
                # 获取原图在 PPT 中的位置和尺寸
                old_left = shape.left
                old_top = shape.top
                old_width = shape.width
                old_height = shape.height
                
                # 计算缩放比例 (原图显示尺寸 / 图片实际像素尺寸)
                # PPTX 内部单位 EMU vs 图片像素
                # 简单处理：我们把新背景图拉伸到和老图一样大
                
                # 1. 插入清洗后的背景图，覆盖在原图位置
                bg_stream = io.BytesIO()
                clean_bg.save(bg_stream, format='PNG')
                bg_stream.seek(0)
                slide.shapes.add_picture(bg_stream, old_left, old_top, old_width, old_height)
                
                # 2. 计算 OCR 坐标的缩放比例
                # 我们在 create_text_boxes_on_slide 里用的是 150 DPI 的假设
                # 这里需要计算 "图片像素" 到 "PPT显示大小" 的转换
                # shape.width 是 EMU。 1 inch = 914400 EMU.
                # 图片实际宽 img_pil.width 像素
                
                # 这里的 Scale 是为了让 OCR 的像素坐标 对齐到 PPT 的 EMU 坐标
                # 逻辑：(OCR像素 / 150) * 914400 * 修正系数 = shape.width
                # 简化逻辑：我们将 create_text_boxes_on_slide 里的 Inches 逻辑复用
                # 我们传入一个 scale 参数，让文字框能对齐到缩放后的图片上
                
                # 计算：如果不缩放，OCR文字在PPT里该有多大？
                # 我们的 px_to_inches 默认 dpi=150。
                # 真实图片宽 w_px -> 在PPT里应该宽 w_px/150 英寸
                expected_width_inches = img_pil.width / 150
                actual_width_inches = old_width / 914400
                
                scale_ratio = actual_width_inches / expected_width_inches
                
                # 3. 插入 OCR 文本框
                create_text_boxes_on_slide(
                    slide, 
                    blocks, 
                    img_pil, 
                    offset_x=old_left, 
                    offset_y=old_top,
                    scale_x=scale_ratio,
                    scale_y=scale_ratio
                )
                
                # 4. 移除原图 (可选，或者把原图移到最底层/隐藏，这里为了保险直接移出画面)
                # python-pptx 删除 shape 比较麻烦，通常做法是移到 -1000, -1000
                shape.left = Inches(-20) 
                
            except Exception as e:
                print(f"  图片处理出错: {e}")
                continue

    prs.save(output_pptx)
    print(f"PPTX 处理完成: {output_pptx}")

def main():
    input_file = "test.pptx"  # 这里可以改 pdf 或 pptx
    output_file = "final_hybrid_v2.pptx"
    
    if not os.path.exists(input_file):
        print(f"找不到文件: {input_file}")
        return

    # 初始化 OCR (只初始化一次)
    ocr_engine = PaddleOCR(use_angle_cls=True, lang="ch", show_log=False)
    
    file_ext = os.path.splitext(input_file)[1].lower()
    
    if file_ext == ".pdf":
        process_pdf_file(input_file, output_file, ocr_engine)
    elif file_ext in [".pptx", ".ppt"]:
        process_pptx_file(input_file, output_file, ocr_engine)
    else:
        print("不支持的文件格式，仅支持 .pdf 和 .pptx")

if __name__ == "__main__":
    main()