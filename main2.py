import os
import io
import math
import numpy as np
from PIL import Image
import cv2

from pdf2image import convert_from_path
from paddleocr import PaddleOCR
from pptx import Presentation
from pptx.util import Pt, Inches
from pptx.dml.color import RGBColor
from pptx.enum.text import MSO_ANCHOR, MSO_AUTO_SIZE

# ================= 配置区域 =================
POPPLER_PATH = None
WATERMARK_KEYWORDS = ["notebooklm", "generated by", "google"]
FONT_SCALE = 0.45  # 保守的字体大小比例


# ===========================================

def px_to_inches(px, dpi=72):
    return px / dpi


def get_conservative_font_size(h_px):
    pt = h_px * FONT_SCALE
    if pt > 24:
        return 24
    elif pt > 18:
        return 18
    elif pt > 14:
        return 14
    elif pt > 11:
        return 11
    elif pt > 9:
        return 10
    else:
        return 9


def get_text_color_kmeans(pil_image, box):
    """
    【核心升级】K-Means 聚类取色
    使用机器学习聚类算法，将框内像素分为两类（背景和前景）。
    数量少的那个聚类通常就是文字颜色。
    """
    try:
        img_np = np.array(pil_image)
        x1, y1 = max(0, int(box[0][0])), max(0, int(box[0][1]))
        x2, y2 = min(img_np.shape[1], int(box[2][0])), min(img_np.shape[0], int(box[2][1]))

        if x2 <= x1 or y2 <= y1: return RGBColor(0, 0, 0)

        # 1. 截取区域
        roi = img_np[y1:y2, x1:x2]
        if roi.size == 0: return RGBColor(0, 0, 0)

        # 转为 RGB
        if roi.shape[2] == 4:
            roi = cv2.cvtColor(roi, cv2.COLOR_RGBA2RGB)
        elif roi.shape[2] == 1:
            roi = cv2.cvtColor(roi, cv2.COLOR_GRAY2RGB)

        # 2. 数据扁平化 (重塑为像素列表)
        data = roi.reshape((-1, 3))
        data = np.float32(data)

        # 3. K-Means 聚类 (K=2, 分为背景和前景)
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
        # 聚类成 2 类
        K = 2
        _, labels, centers = cv2.kmeans(data, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

        # 4. 统计哪一类像素更少 (文字通常占面积小)
        count_0 = np.sum(labels == 0)
        count_1 = np.sum(labels == 1)

        # 取像素少的那个作为文字颜色
        text_color_idx = 0 if count_0 < count_1 else 1
        color = centers[text_color_idx]

        r, g, b = int(color[0]), int(color[1]), int(color[2])

        # 防御性编程：如果取到了纯白(255,255,255)，大概率是取反了或者字太细
        # 这种情况下回退到深灰
        if r > 240 and g > 240 and b > 240:
            return RGBColor(20, 20, 20)

        return RGBColor(r, g, b)

    except Exception:
        return RGBColor(0, 0, 0)


def smart_background_clean_aggressive(pil_image, ocr_result):
    """
    【核心升级】强力膨胀修复
    解决“脏”的问题：通过大幅度膨胀遮罩，确保文字边缘的虚化像素
    全部被纳入修复范围，不留任何残渣。
    """
    img_np = np.array(pil_image)
    if img_np.shape[2] == 4:
        img_np = cv2.cvtColor(img_np, cv2.COLOR_RGBA2RGB)
    img_cv = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)

    mask = np.zeros(img_cv.shape[:2], dtype=np.uint8)

    if ocr_result:
        for line in ocr_result:
            box = line[0]
            points = np.array(box, dtype=np.int32)
            cv2.fillPoly(mask, [points], 255)

    # 1. 强力膨胀 (Aggressive Dilation)
    # 这里的核设置得比较大 (20, 8)，横向狂吃，纵向多吃
    # 目的是把文字彻底覆盖住，连同旁边的噪点一起修掉
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (20, 8))
    dilated_mask = cv2.dilate(mask, kernel, iterations=2)  # 迭代2次，确保覆盖

    # 2. 边缘羽化
    feathered_mask = cv2.GaussianBlur(dilated_mask, (15, 15), 0)

    # 3. 修复
    # 半径设为 5，使用 TELEA 算法 (处理强力擦除效果通常比 NS 好)
    clean_img_cv = cv2.inpaint(img_cv, feathered_mask, 5, cv2.INPAINT_TELEA)

    clean_img_rgb = cv2.cvtColor(clean_img_cv, cv2.COLOR_BGR2RGB)
    return Image.fromarray(clean_img_rgb)


def merge_text_blocks(ocr_data):
    """段落合并逻辑 (保持稳定)"""
    if not ocr_data: return []
    sorted_data = sorted(ocr_data, key=lambda x: x[0][0][1])
    merged_blocks = []

    current_block = {
        'lines': [sorted_data[0][1][0]],
        'box': sorted_data[0][0],
        'avg_height': (sorted_data[0][0][2][1] - sorted_data[0][0][0][1]),
        'sample_box': sorted_data[0][0]  # 取色样本
    }

    for i in range(1, len(sorted_data)):
        line = sorted_data[i]
        box = line[0]
        text = line[1][0]
        h = box[2][1] - box[0][1]

        prev_box = current_block['box']
        v_dist = box[0][1] - prev_box[2][1]
        h_diff = abs(box[0][0] - prev_box[0][0])
        height_diff = abs(h - current_block['avg_height'])

        if v_dist < 30 and h_diff < 50 and height_diff < 15:
            current_block['lines'].append(text)
            new_x1 = min(prev_box[0][0], box[0][0])
            new_y1 = prev_box[0][1]
            new_x2 = max(prev_box[2][0], box[2][0])
            new_y2 = box[2][1]
            current_block['box'] = [[new_x1, new_y1], [new_x2, new_y1], [new_x2, new_y2], [new_x1, new_y2]]
            current_block['avg_height'] = (current_block['avg_height'] + h) / 2
        else:
            merged_blocks.append(current_block)
            current_block = {
                'lines': [text],
                'box': box,
                'avg_height': h,
                'sample_box': box
            }
    merged_blocks.append(current_block)
    return merged_blocks


def convert_pdf_to_editable_ppt(pdf_path, output_ppt_path):
    print(f"--- 启动转换: K-Means聚类取色 + 强力清洗背景 ---")

    ocr = PaddleOCR(use_angle_cls=True, lang="ch", show_log=False)

    try:
        images = convert_from_path(pdf_path, dpi=150, poppler_path=POPPLER_PATH)
    except Exception as e:
        print(f"Error: {e}")
        return

    prs = Presentation()

    for i, img in enumerate(images):
        print(f"处理第 {i + 1} 页...")
        img_w, img_h = img.size

        img_np = np.array(img)
        result = ocr.ocr(img_np, cls=True)
        raw_data = result[0] if result else []

        # 1. 过滤水印
        clean_ocr_data = []
        for line in raw_data:
            text = line[1][0]
            if not any(kw in text.lower() for kw in WATERMARK_KEYWORDS):
                clean_ocr_data.append(line)

        # 2. 【改进】强力背景清洗
        clean_bg_image = smart_background_clean_aggressive(img, raw_data)

        # 3. 段落合并
        merged_blocks = merge_text_blocks(clean_ocr_data)

        # 4. PPT 设置
        slide = prs.slides.add_slide(prs.slide_layouts[6])
        ppt_w = int(px_to_inches(img_w, 150) * 914400)
        ppt_h = int(px_to_inches(img_h, 150) * 914400)
        prs.slide_width = ppt_w
        prs.slide_height = ppt_h

        image_stream = io.BytesIO()
        clean_bg_image.save(image_stream, format='JPEG', quality=95)
        image_stream.seek(0)
        slide.shapes.add_picture(image_stream, 0, 0, width=ppt_w, height=ppt_h)

        # 5. 生成文本框
        for block in merged_blocks:
            box = block['box']
            lines = block['lines']
            avg_h = block['avg_height']

            # 【改进】K-Means 聚类取色
            text_color = get_text_color_kmeans(img, block['sample_box'])

            full_text = "\n".join(lines)

            x1, y1 = box[0]
            w_px = box[2][0] - x1
            h_px = box[2][1] - y1

            left = Inches(px_to_inches(x1, 150))
            top = Inches(px_to_inches(y1, 150))
            width = Inches(px_to_inches(w_px, 150))
            height = Inches(px_to_inches(h_px, 150))

            txBox = slide.shapes.add_textbox(left, top, width, height)

            # 透明背景
            txBox.fill.background()

            tf = txBox.text_frame
            tf.word_wrap = False
            tf.auto_size = MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT
            tf.margin_left = 0
            tf.margin_right = 0
            tf.margin_top = 0
            tf.margin_bottom = 0

            p = tf.paragraphs[0]
            p.text = full_text
            p.font.name = 'Microsoft YaHei'
            p.font.color.rgb = text_color
            p.font.size = Pt(get_conservative_font_size(avg_h))
            p.line_spacing = 1.1

    try:
        prs.save(output_ppt_path)
        print(f"\n成功！文件已保存至: {output_ppt_path}")
        print(
            "升级说明：\n1. 背景清洗力度增强(Aggressive)，确保无残留脏点。\n2. 取色算法升级为 K-Means 机器学习聚类，极准。")
    except PermissionError:
        print(f"无法保存: {output_ppt_path}")


if __name__ == "__main__":
    input_file = "test.pdf"
    output_file = "final_clean_kmeans.pptx"

    if os.path.exists(input_file):
        convert_pdf_to_editable_ppt(input_file, output_file)
    else:
        print(f"，恭喜发财，找不到文件: {input_file}")